setwd("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes")
cia_wf_data <- read.csv("countries.csv")
colnames_for_anlysis <- c("Country","People.and.Society..Life.expectancy.at.birth...male",
"People.and.Society..Life.expectancy.at.birth...female",
"Economy..Real.GDP..purchasing.power.parity.")
cia_wf_data_le_vs_gdp <- cia_wf_data %>% dplyr::select(all_of(colnames_for_anlysis))
index_2023 <- (grepl("(2023 est.)", cia_wf_data_le_vs_gdp$Economy..Real.GDP..purchasing.power.parity., fixed = TRUE))
cia_wf_data_2023 <- cia_wf_data_le_vs_gdp[index_2023,]
library(dplyr)
cia_wf_data <- read.csv("countries.csv")
colnames_for_anlysis <- c("Country","People.and.Society..Life.expectancy.at.birth...male",
"People.and.Society..Life.expectancy.at.birth...female",
"Economy..Real.GDP..purchasing.power.parity.")
cia_wf_data_le_vs_gdp <- cia_wf_data %>% dplyr::select(all_of(colnames_for_anlysis))
index_2023 <- (grepl("(2023 est.)", cia_wf_data_le_vs_gdp$Economy..Real.GDP..purchasing.power.parity., fixed = TRUE))
cia_wf_data_2023 <- cia_wf_data_le_vs_gdp[index_2023,]
index_bil <- (grepl("billion (2023 est.)", cia_wf_data_2023$Economy..Real.GDP..purchasing.power.parity., fixed = TRUE))
index_tril <- (grepl("trillion (2023 est.)", cia_wf_data_2023$Economy..Real.GDP..purchasing.power.parity., fixed = TRUE))
index_mil <- (grepl("million (2023 est.)", cia_wf_data_2023$Economy..Real.GDP..purchasing.power.parity., fixed = TRUE))
colnames(cia_wf_data_2023) <- c("Country",
"Life_expectancy_M",
"Life_expectancy_F",
"GDP_PPP")
library(readr)
cia_wf_data_2023 = cia_wf_data_2023 %>%
mutate(across(-c(Country),.fns = parse_number))
cia_wf_data_2023$GDP_PPP[index_bil] = 1000 * cia_wf_data_2023$GDP_PPP[index_bil]
cia_wf_data_2023$GDP_PPP[index_tril] = 1000000 * cia_wf_data_2023$GDP_PPP[index_tril]
cia_wf_data_2023 <- na.omit(cia_wf_data_2023)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Life_expectancy_M)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Life_expectancy_F)
U1 = ecdf(cia_wf_data_2023$Life_expectancy_F)(cia_wf_data_2023$Life_expectancy_F)
U2 = ecdf(cia_wf_data_2023$Life_expectancy_M)(cia_wf_data_2023$Life_expectancy_M)
plot(U1,U2)
plot(cia_wf_data_2023$Life_expectancy_F,cia_wf_data_2023$Life_expectancy_M)
GDP <- as.data.frame((log(cia_wf_data_2023$GDP_PPP) - min(log(cia_wf_data_2023$GDP_PPP)))/(max(log(cia_wf_data_2023$GDP_PPP)) - min(log(cia_wf_data_2023$GDP_PPP))))
GDP <- as.matrix(GDP)
rownames(GDP) <- 1:nrow(GDP)
n.chain_par <- 1
n.iter_par <- 6000
n.born.out.par <- 1000
n.thin <- 1
incl.split_par <- TRUE
cont.unif_par <- TRUE
moves.prob_par <- c(0.4, 0.4, 0.1, 0.1)
n.tree <- 10
# packages
library(data.tree)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(VineCopula)
library(MASS)   # For multivariate normal functions
library(coda)   # For MCMC diagnostics
library(plot3D)
library(gplots)
library(xtable)
require(foreach)
require(parallel)
require(doParallel)
library(calculus)
# source('MCMC_BART_copula.R')
source('import_functions.R')
source('test_MCMC_copula_mult_tree.R')
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
t_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "t")
lb.prior.def <- list(fun = joint.prior.new.tree, param = c(1.5618883, 0.6293944))
t_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "t")
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
View(sample.cond.mu.copula_after_burn)
try_mat <- matrix(NA)
try_mat[-1,-1]
1 + try_mat[-1,-1]
1 + try_mat[-1,1] %*% try_mat[-1,-1] %*% t(try_mat[-1,1])
1 + try_mat[1,-1] %*% try_mat[-1,-1] %*% t(try_mat[1,-1])
try_mat[1,-1] %*% try_mat[-1,-1] %*% t(try_mat[1,-1])
try_mat[1,-1]
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
t_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "t")
View(sample.cond.mu.copula_after_burn)
View(sample.cond.mu.copula_before_burn)
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
t_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "t")
gauss_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss")
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
clayton_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "clayton")
gauss_list_pred_lb <- lapply(1:length(gauss_GDP_tree_1$trees), \(idx) BART_calculate_pred(gauss_GDP_tree_1$trees[[idx]], GDP))
gauss_pred_val = do.call(rbind,gauss_list_pred_lb)
gauss_pred_val_vec = as.vector(gauss_pred_val[(1:(n.chain_par * n.iter_par))[rep((n.born.out.par+1):n.iter_par, n.chain_par) + rep(n.iter_par * (0:(n.chain_par-1)), each = (n.iter_par - n.born.out.par))],])
frank_list_pred_lb <- lapply(1:length(frank_GDP_tree_1$trees), \(idx) BART_calculate_pred(frank_GDP_tree_1$trees[[idx]], GDP))
frank_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "frank")
warnings()
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
frank_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "frank")
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
frank_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "frank")
frank_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "frank")
eig(cov_mat)
sapply(idx.tree.vec, function(i)sqrt(cov_mat[i,i] - cov_mat[i,-i]%*%cov_mat[-i,-i]%*%cov_mat[-i,i]))
cov_mat
cov_mat == t(cov_mat)
cov_mat[i,i] - cov_mat[i,-i]%*%cov_mat[-i,-i]%*%cov_mat[-i,i]
sapply(idx.tree.vec, function(i)(cov_mat[i,i] - cov_mat[i,-i]%*%cov_mat[-i,-i]%*%cov_mat[-i,i]))
cov_mat[i,i]
cov_mat[1,1]
cov_mat[1,-1]%*%cov_mat[-1,-1]%*%cov_mat[-1,1]
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
frank_GDP_tree_1 <- MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree,
X = GDP,
U1 = U1,
U2 = U2,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = rep(.2/n.tree,n.tree),
theta_param_1 = 0, theta_param_2 = .3,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "frank")
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/test_MCMC_copula_mult_tree.R")
