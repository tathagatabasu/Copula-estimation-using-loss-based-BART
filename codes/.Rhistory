geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
geom_vline(xintercept = get_num_terminal_nodes(tree_ex),
color = 'darkorange',
linetype = 2) +
facet_wrap(facets = ~panel.name) +
xlab(~n[L]) +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,24,by = 3))
hist.nl <- ggplot(nterm.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab(~n[L]) +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,24,by = 3))
hist.depth <- ggplot(depth.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab('Depth') +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,10,by = 1))
hist.nl
hist.depth
View(get_value_tree)
x_new <- matrix(rnorm(2*n), ncol = 2)
x_new_norm <- sapply(1:ncol(x_new), function(i)(x_new[,i] - min(x_pred[,i]))/(max(x_pred[,i])- min(x_pred[,i])))
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm[1,]),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
x_new
x_new_norm
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm[1:2,]),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
x_new_norm <- as.data.frame(sapply(1:ncol(x_new), function(i)(x_new[,i] - min(x_pred[,i]))/(max(x_pred[,i])- min(x_pred[,i]))))
X_new_norm <- as.matrix(x_new_norm)
rownames(x_new_norm) <- 1:nrow(X_pred.norm)
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
View(apply_fun_models)
get_value_tree(model.list.def[[1]]$trees,x_new_norm)
model.list.def[[1]]$trees
get_value_tree(model.list.def[[1]]$trees,X_pred.norm)
g.T(model.list.def[[1]]$trees, X_pred[1, ])
g.T(model.list.def[[1]]$trees, X_pred[2, ])
g.T(model.list.def[[1]]$trees, X_pred[4, ])
g.T(model.list.def[[2]]$trees, X_pred[4, ])
model.list.def
View(model.list.def)
g.T(model.list.def[[1]]$trees, X_pred[4, ])
g.T(model.list.def[[1]]$trees[[1]], X_pred[4, ])
g.T(model.list.def[[1]]$trees[[23]], X_pred[4, ])
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
get_value_tree(model.list.def[[1]]$trees,X_pred.norm)
View(get_value_tree)
nrow(X_pred.norm)
get_value_tree(model.list.def[[1]]$trees, X= X_pred.norm)
cbind(XX[1:5,], tree_value = get_value_tree(tree_top, XX[1:5,]))
#' @export
#'
#' @examples
#' tree_top <- generate_random_binary_tree(4,5)
#' tree_top <- assign_node_idx(tree_top)
#' XX <- data.frame(x1 = rnorm(100), x2 = sample(c('A', 'B'), 500, replace = TRUE))
#' tree_top <- assign_split_rules(tree_top, XX)
#' tree_top <- assign_term_node_values(tree_top, 0, 10)
#' get_tree_plot(tree_top)
#' cbind(XX[1:5,], tree_value = get_value_tree(tree_top, XX[1:5,]))
get_value_tree <- function(tree_top, X){
print(nrow(X))
vapply(1:nrow(X), \(idx) g.T(tree_top, X[idx,]), 0)
}
get_value_tree(model.list.def[[1]]$trees[[1]], X= X_pred.norm)
#' @export
#'
#' @examples
#' tree_top <- generate_random_binary_tree(4,5)
#' tree_top <- assign_node_idx(tree_top)
#' XX <- data.frame(x1 = rnorm(100), x2 = sample(c('A', 'B'), 500, replace = TRUE))
#' tree_top <- assign_split_rules(tree_top, XX)
#' tree_top <- assign_term_node_values(tree_top, 0, 10)
#' get_tree_plot(tree_top)
#' cbind(XX[1:5,], tree_value = get_value_tree(tree_top, XX[1:5,]))
get_value_tree <- function(tree_top, X){
vapply(1:nrow(X), \(idx) g.T(tree_top, X[idx,]), 0)
}
get_value_tree(model.list.def[[1]]$trees[[1]], X= X_pred.norm)
get_value_tree(model.list.def[[1]]$trees[[1]], X= X_pred.norm[1:2,])
View(apply_fun_models)
pred_cond = apply_fun_models(fun_ = function(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
model.list.def[[1]]$trees[1]
model.list.def[[1]]$trees[2]
model.list.def[[1]]$trees[3]
get_value_tree(model.list.def[[1]]$trees[1], X= X_pred.norm[1:2,])
get_value_tree(model.list.def[[1]]$trees[[1]], X= X_pred.norm[1:2,])
model.list.def[[1]]$trees[2]
model.list.def[[1]]$trees[[2]]
unlist(model.list.def[[1]]$trees[2])
pred_cond = apply_fun_models(fun_ = \(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
View(apply_fun_models)
source("C:/Users/ntb148/Documents/Github/Copula-estimation-using-loss-based-BART/codes/code/tree_utils.R")
pred_cond = apply_fun_models(fun_ = \(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
View(get_terminal_nodes_idx)
View(get_num_terminal_nodes)
View(apply_fun_models)
View(apply_fun_models_all.tog)
View(apply_fun_models)
pred_cond = apply_fun_models(fun_ = \(tree_in) get_value_tree(tree_in,x_new_norm),
mcmc.list = model.list.def,
born.out.pc =0, n.chain = n.chain_par, sample.pc = n.iter_par)
get_value_tree(model.list.def[[1]]$trees[[1]],x_new_norm)
get_value_tree(model.list.def[[1]]$trees[[2]],x_new_norm)
get_value_tree(model.list.def[[1]]$trees[[4]],x_new_norm)
get_value_tree(model.list.def[[1]]$trees[[7]],x_new_norm)
get_value_tree(model.list.def[[1]]$trees[[100]],x_new_norm)
View(model.list.def)
pred_cond = sapply(1:length(model.list.def$`LB - default`$trees), function(i)get_value_tree(model.list.def[[1]]$trees[[i]],x_new_norm))
est_rho = colMeans(pred_cond)
est_rho = rowMeans(pred_cond)
calib_true_new <- 1+x_new %*% c(.2,1)
rho_true_new <- (exp(2*calib_true_new)-1)/ (exp(2*calib_true_new)+1)
plot(rho_true_new, est_rho)
Y_mal <- 1/2 *log((1+sample_rho)/(1-sample_rho))
Y_mal <- (Y_mal - max(Y_mal))/(max(Y_mal)-min(Y_mal))
cor(X_pred.norm, Y_mal)
n.chain_par <- 5
n.iter_par <- 500
incl.split_par <- FALSE
cont.unif_par <- TRUE
moves.prob_par <- c(0.3, 0.3, 0.3, 0.1)
lb.prior.def <- list(fun = joint.prior.new.tree, param = c(1.56, 0.62))
mcmc_lb.def <- multichain_MCMC_known_var(n.chain = n.chain_par,
n.iter = n.iter_par,
X = X_pred.norm,
Y = Y_mal,
Y.var = 1,
n.cores = 5,
mu.prior.mean = 0,
mu.prior.var = var(Y_mal),
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par)
model.list.def <- list(
mcmc_lb.def)
names(model.list.def) <- c(
'LB - default')
# extract depth, number of terminal nodes, missing rate and loglik of all the trees
depth.df <- apply_fun_models(fun_ = get_depth,
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
View(apply_fun_models)
source("C:/Users/ntb148/Documents/Github/Copula-estimation-using-loss-based-BART/codes/code/tree_utils.R")
# extract depth, number of terminal nodes, missing rate and loglik of all the trees
depth.df <- apply_fun_models(fun_ = get_depth,
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
nterm.df <- apply_fun_models(fun_ = get_num_terminal_nodes,
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
hist.nl <- ggplot(nterm.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab(~n[L]) +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,24,by = 3))
hist.depth <- ggplot(depth.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab('Depth') +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,10,by = 1))
hist.nl
hist.depth
x_new <- matrix(rnorm(2*n), ncol = 2)
calib_true_new <- 1+x_new %*% c(.2,1)
rho_true_new <- (exp(2*calib_true_new)-1)/ (exp(2*calib_true_new)+1)
x_new_norm <- as.data.frame(sapply(1:ncol(x_new), function(i)(x_new[,i] - min(x_pred[,i]))/(max(x_pred[,i])- min(x_pred[,i]))))
X_new_norm <- as.matrix(x_new_norm)
rownames(x_new_norm) <- 1:nrow(X_pred.norm)
pred_cond = sapply(1:length(model.list.def$`LB - default`$trees), function(i)get_value_tree(model.list.def[[1]]$trees[[i]],x_new_norm))
est_rho_link = rowMeans(pred_cond)
est_rho = (exp(2*est_rho_link)-1)/ (exp(2*est_rho_link)+1)
plot(est_rho, rho_new_true)
plot(est_rho, rho_true_new)
plot(est_rho_link, rho_true_new)
plot(rho_true, sample_rho)
plot(est_rho_link, calib_true_new)
plot(rho_true, sample_rho)
hist.nl
hist.depth
plot(est_rho_link, calib_true_new)
plot(rho_true, sample_rho)
est_rho_link = rowSums(pred_cond)
est_rho = (exp(2*est_rho_link)-1)/ (exp(2*est_rho_link)+1)
plot(est_rho_link, calib_true_new)
View(multichain_MCMC_known_var)
View(MCMC_known_var)
View(tree_step)
View(acceptance.prob.list)
View(cart_log_lik)
View(cart_log_lik)
install.packages("VineCopula")
library(VineCopula) # VineCopula
?VineCopula
Y_mal
plot(calib_true, Y_mal)
plot(rho_true, sample_rho)
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- rep(1/n,n)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
triweight <- function(u){
35/32*(1-sum(u^2))^3 *(sum(u^2)<1)
}
NW_weights <- function(x, x_obs, band = 2.7 * (1/nrow(x_obs))^.2){
wt <- apply(x_obs, 1, function(t)triweight((x-t)/band))
return(wt/sum(wt))
}
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- NW_weights(x, x_obs)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
epanechnikov <- function(u){
3/4*(1-sum(u^2)) *(sum(u^2)<1)
}
NW_weights <- function(x, x_obs, band = 2.7 * (1/nrow(x_obs))^.2){
wt <- apply(x_obs, 1, function(t)epanechnikov((x-t)/band))
return(wt/sum(wt))
}
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- NW_weights(x, x_obs)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
hist(rho_true)
# Define true copula parameter
calib_true <- x_pred %*% c(.2,1)
rho_true <- (exp(2*calib_true)-1)/ (exp(2*calib_true)+1)
hist(rho_true)
# generate predictor
n <- 500
x_pred <- matrix(runif(2*n, min = -1), ncol = 2)
# Define true copula parameter
calib_true <- x_pred %*% c(.2,1)
hist(calib_true)
rho_true <- (exp(2*calib_true)-1)/ (exp(2*calib_true)+1)
hist(rho_true)
# Define the Gaussian copula
cop <- sapply(rho_true, function(x)normalCopula(param = x, dim = 2))
# Generate uniform data from the copula
u <- lapply(cop, function(x)rCopula(1, x))
u <- matrix(unlist(u), ncol = 2, byrow = T)
# Convert to normal marginals
y1 <- qnorm(u[,1])
y2 <- qnorm(u[,2])
# empirical cdf function
ecdf_y1 = ecdf(y1)
ecdf_y2 = ecdf(y2)
##################################################
pseudo_u1 = sapply(y1, ecdf_y1)
pseudo_u2 = sapply(y2, ecdf_y2)
triweight <- function(u){
35/32*(1-sum(u^2))^3 *(sum(u^2)<1)
}
epanechnikov <- function(u){
3/4*(1-sum(u^2)) *(sum(u^2)<1)
}
gaussweight <- function(x){
exp(-sum(x^2)/2)/(sqrt(2*pi))^length(x)
}
NW_weights <- function(x, x_obs, band = 2.7 * (1/nrow(x_obs))^.2){
wt <- apply(x_obs, 1, function(t)epanechnikov((x-t)/band))
return(wt/sum(wt))
}
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- NW_weights(x, x_obs)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
NW_weights <- function(x, x_obs, band = 2.7 * (1/nrow(x_obs))^.2){
wt <- apply(x_obs, 1, function(t)gaussweight((x-t)/band))
return(wt/sum(wt))
}
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- NW_weights(x, x_obs)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
NW_weights <- function(x, x_obs, band = 2 * (1/nrow(x_obs))^.2){
wt <- apply(x_obs, 1, function(t)gaussweight((x-t)/band))
return(wt/sum(wt))
}
rho.cond=function(uu, x, x_obs)
{
uu1=uu[,1]
uu2=uu[,2]
estim=c()
n <- nrow(uu)
ww <- NW_weights(x, x_obs)
# Compute uu.hat
uu1.hat=c()
uu2.hat=c()
for(i in 1:n)
{
uu1.hat[i]=sum(ww*(uu1<=uu1[i]))
uu2.hat[i]=sum(ww*(uu2<=uu2[i]))
}
estim=12*sum(ww*(1-uu1.hat)*(1-uu2.hat))-3
# Return
return(estim)
}
sample_rho = apply(x_pred, 1, function(x)rho.cond(cbind(pseudo_u1,pseudo_u2), x, x_pred))
plot(rho_true, sample_rho)
X_pred <- x_pred
summary(X_pred)
Y_mal <- 1/2 *log((1+sample_rho)/(1-sample_rho))
plot(calib_true, Y_mal)
############################################################
#
# normalise predictors
X_pred.norm <- as.data.frame(apply(X_pred, 2, \(x) (x - min(x))/(max(x) - min(x))))
X_pred.norm <- as.matrix(X_pred.norm)
rownames(X_pred.norm) <- 1:nrow(X_pred.norm)
Y_mal <- (Y_mal - max(Y_mal))/(max(Y_mal)-min(Y_mal))
cor(X_pred.norm, Y_mal)
n.chain_par <- 5
n.iter_par <- 500
incl.split_par <- FALSE
cont.unif_par <- TRUE
moves.prob_par <- c(0.3, 0.3, 0.3, 0.1)
lb.prior.def <- list(fun = joint.prior.new.tree, param = c(1.56, 0.62))
mcmc_lb.def <- multichain_MCMC_known_var(n.chain = n.chain_par,
n.iter = n.iter_par,
X = X_pred.norm,
Y = Y_mal,
Y.var = 1,
n.cores = 5,
mu.prior.mean = 0,
mu.prior.var = var(Y_mal),
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par)
model.list.def <- list(
mcmc_lb.def)
names(model.list.def) <- c(
'LB - default')
# extract depth, number of terminal nodes, missing rate and loglik of all the trees
depth.df <- apply_fun_models(fun_ = get_depth,
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
nterm.df <- apply_fun_models(fun_ = get_num_terminal_nodes,
mcmc.list = model.list.def,
born.out.pc = 250, n.chain = n.chain_par, sample.pc = n.iter_par)
hist.nl <- ggplot(nterm.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab(~n[L]) +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,24,by = 3))
hist.depth <- ggplot(depth.df) +
geom_histogram(aes(x = y, y = after_stat(density)),
binwidth = 1, color = 'black', fill = 'white') +
facet_wrap(facets = ~panel.name) +
xlab('Depth') +
ylab('PMF') +
theme_classic() +
scale_x_continuous(breaks = seq(0,10,by = 1))
hist.nl
hist.depth
x_new <- matrix(rnorm(2*n), ncol = 2)
x_new <- matrix(runif(2*n, min = -1), ncol = 2)
calib_true_new <- x_new %*% c(.2,1)
rho_true_new <- (exp(2*calib_true_new)-1)/ (exp(2*calib_true_new)+1)
x_new_norm <- as.data.frame(sapply(1:ncol(x_new), function(i)(x_new[,i] - min(x_pred[,i]))/(max(x_pred[,i])- min(x_pred[,i]))))
X_new_norm <- as.matrix(x_new_norm)
rownames(x_new_norm) <- 1:nrow(X_pred.norm)
pred_cond = sapply(1:length(model.list.def$`LB - default`$trees), function(i)get_value_tree(model.list.def[[1]]$trees[[i]],x_new_norm))
est_rho_link = rowSums(pred_cond)
est_rho_link = rowMeans(pred_cond)
Y_mal <- 1/2 *log((1+sample_rho)/(1-sample_rho))
est_rho_link = rowMeans(pred_cond) * (max(Y_mal) - min(Y_mal)) + min(Y_mal)
plot(est_rho_link, calib_true_new)
est_rho = (exp(2*est_rho_link)-1)/ (exp(2*est_rho_link)+1)
plot(est_rho, rho_true_new)
plot(est_rho_link, calib_true_new)
est_rho_link = rowMeans(pred_cond) * (max(Y_mal) - min(Y_mal)
est_rho_link = rowMeans(pred_cond) * (max(Y_mal) - min(Y_mal))
est_rho_link = rowMeans(pred_cond) * (max(Y_mal) - min(Y_mal))
est_rho = (exp(2*est_rho_link)-1)/ (exp(2*est_rho_link)+1)
plot(est_rho_link, calib_true_new)
plot(est_rho_link, calib_true_new)
plot(est_rho_link, calib_true_new)
est_rho_link = rowMeans(pred_cond)
est_rho = (exp(2*est_rho_link)-1)/ (exp(2*est_rho_link)+1)
plot(est_rho_link, calib_true_new)
plot(est_rho, rho_true_new)
View(get_value_tree)
