plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Life_expectancy_M)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Life_expectancy_F)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Liter_M)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Liter_F)
U1_LE = ecdf(cia_wf_data_2023$Life_expectancy_F)(cia_wf_data_2023$Life_expectancy_F)
U2_LE = ecdf(cia_wf_data_2023$Life_expectancy_M)(cia_wf_data_2023$Life_expectancy_M)
U1_LT = ecdf(cia_wf_data_2023$Liter_F)(cia_wf_data_2023$Liter_F)
U2_LT = ecdf(cia_wf_data_2023$Liter_M)(cia_wf_data_2023$Liter_M)
plot(U1_LE,U2_LE)
plot(cia_wf_data_2023$Life_expectancy_F,cia_wf_data_2023$Life_expectancy_M)
plot(U1_LT,U2_LT)
plot(cia_wf_data_2023$Liter_F,cia_wf_data_2023$Liter_M)
GDP <- as.data.frame((log(cia_wf_data_2023$GDP_PPP) - min(log(cia_wf_data_2023$GDP_PPP)))/(max(log(cia_wf_data_2023$GDP_PPP)) - min(log(cia_wf_data_2023$GDP_PPP))))
GDP <- as.matrix(GDP)
rownames(GDP) <- 1:nrow(GDP)
n.chain_par <- 10
n.iter_par <- 15000
n.born.out.par <- 1000
n.thin <- 1
incl.split_par <- TRUE
cont.unif_par <- TRUE
moves.prob_par <- c(0.1, 0.4, 0.25, 0.25)
n.tree <- 10
cramer.test(cbind(U1_LE,U2_LE), cbind(U1_LE,U2_LE))
library(cramer)
cramer.test(cbind(U1_LE,U2_LE), cbind(U1_LE,U2_LE))
cramer.test(cbind(U1_LE,U2_LE), cbind(t_pred_U1_LE, t_pred_U2_LE), replicates = 10000, sim = "permutation")
cramer.test(cbind(U1_LE,U2_LE), cbind(gauss_pred_U1_LE, gauss_pred_U2_LE), replicates = 10000)
cramer.test(cbind(U1_LE,U2_LE), cbind(frank_pred_U1_LE, frank_pred_U2_LE), replicates = 10000)
library(fasano.franceschini.test)
fasano.franceschini.test(cbind(U1_LE,U2_LE), cbind(U1_LE,U2_LE))
fasano.franceschini.test(cbind(U1_LE,U2_LE), cbind(t_pred_U1_LE, t_pred_U2_LE))
fasano.franceschini.test(cbind(U1_LE,U2_LE), cbind(gauss_pred_U1_LE, gauss_pred_U2_LE))
fasano.franceschini.test(cbind(U1_LE,U2_LE), cbind(frank_pred_U1_LE, frank_pred_U2_LE))
hist_true <- hist2d(U1_LE, U2_LE, nbins = c(10,10), show = FALSE)
par(mar = c(1,1,1,1), mfrow = c(2,3))
hist3D(
x = hist_true$x,
y = hist_true$y,
z = hist_true$counts,
colvar = NULL,  # disables color mapping
col = "lightblue",  # solid monochrome color
border = "black",
theta = -30, scale = FALSE, expand = 0.02, bty = "g", phi = 45,    # shading gives 3D effect
lighting = TRUE,
ltheta = 120, ticktype = "detailed",
xlab = "", ylab = "", zlab = "",
main = "Observed copula"
)
hist3D(
x = hist_gauss$x,
y = hist_gauss$y,
z = hist_gauss$counts,
colvar = NULL,  # disables color mapping
col = "lightblue",  # solid monochrome color
border = "black",
theta = -30, scale = FALSE, expand = 0.02, bty = "g", phi = 45,    # shading gives 3D effect
lighting = TRUE,
ltheta = 120, ticktype = "detailed",
xlab = "", ylab = "", zlab = "",
main = "Gauss"
)
hist3D(
x = hist_t$x,
y = hist_t$y,
z = hist_t$counts,
colvar = NULL,  # disables color mapping
col = "lightblue",  # solid monochrome color
border = "black",
theta = -30, scale = FALSE, expand = 0.02, bty = "g", phi = 45,    # shading gives 3D effect
lighting = TRUE,
ltheta = 120, ticktype = "detailed",
xlab = "", ylab = "", zlab = "",
main = "student t"
)
hist3D(
x = hist_frank$x,
y = hist_frank$y,
z = hist_frank$counts,
colvar = NULL,  # disables color mapping
col = "lightblue",  # solid monochrome color
border = "black",
theta = -30, scale = FALSE, expand = 0.02, bty = "g", phi = 45,    # shading gives 3D effect
lighting = TRUE,
ltheta = 120, ticktype = "detailed",
xlab = "", ylab = "", zlab = "",
main = "Frank"
)
library(ks)
kde.test(cbind(U1_LE,U2_LE), cbind(t_pred_U1_LE, t_pred_U2_LE))
kde.test(cbind(U1_LE,U2_LE), cbind(frank_pred_U1_LE, frank_pred_U2_LE))
plot(U1_LE,U2_LE)
plot(gauss_pred_U1_LE,gauss_pred_U2_LE)
plot(U1_LE,U2_LE)
plot(frank_pred_U1_LE,frank_pred_U2_LE)
plot(U1_LE,U2_LE)
plot(t_pred_U1_LE,t_pred_U2_LE)
plot(U1_LE,U2_LE)
plot(t_pred_U1_LE,t_pred_U2_LE)
source('mclapply.R')
# source('MCMC_BART_copula.R')
source('import_functions.R')
source('test_MCMC_copula_mult_tree.R')
View(multichain_MCMC_copula)
View(mclapply_cbart)
sessionInfo()$otherPkgs
sessionInfo()$basePkgs
# packages
# library(data.tree)
# require(foreach)
# require(parallel)
# require(doParallel)
library(VineCopula)
load("analysis_sim_dat_red.RData")
source('mclapply.R')
# source('MCMC_BART_copula.R')
source('import_functions.R')
source('test_MCMC_copula_mult_tree.R')
lsf.str()
ls
ls()
?ls
lsf.str()
lsf()
lsf.str()
?lsf.str
ls.str()
lsf.str(all.names = T)
names(lsf.str(all.names = T))
(lsf.str(all.names = T))
(lsf.str(all.names = T))[1]
c(lsf.str(all.names = T))
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/mclapply.R")
n.tree <- 1
for (i in 2) {
assign(paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = X_obs.norm,
U1 = get(paste0("copula_uu_gauss_",i))[,1],
U2 = get(paste0("copula_uu_gauss_",i))[,2],
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .4,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T))
cat('done case', i, '\n')
save(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), file = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt", ".Rdata"))
rm(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"))
}
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/mclapply.R")
for (i in 2) {
assign(paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = X_obs.norm,
U1 = get(paste0("copula_uu_gauss_",i))[,1],
U2 = get(paste0("copula_uu_gauss_",i))[,2],
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .4,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T))
cat('done case', i, '\n')
save(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), file = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt", ".Rdata"))
rm(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"))
}
source("~/Documents/GitHub/Copula-estimation-using-loss-based-BART/codes/mclapply.R")
sessionInfo()
sessionInfo()$otherPkgs
# packages
# library(data.tree)
# require(foreach)
# require(parallel)
# require(doParallel)
library(VineCopula)
if(F){
library(dplyr)
library(ggplot2)
library(ggpubr)
library(MASS)   # For multivariate normal functions
library(coda)   # For MCMC diagnostics
library(plot3D)
library(gplots)
library(xtable)
library(patchwork)
library(parallel)
library(mc2d)
library(pracma)
library(MCMCpack)
}
################################################################################
# data generation
################################################################################
set.seed(1e3)
if(F){
n <- 500
X_obs <- matrix(runif(n), ncol = 1)
# normalise predictors
X_obs.norm <- as.data.frame(apply(X_obs, 2, \(x) (x - min(x))/(max(x) - min(x))))
X_obs.norm <- as.matrix(X_obs.norm)
rownames(X_obs.norm) <- 1:nrow(X_obs)
# tau with tree structure
tau_true_tree <- rep(0,nrow(X_obs))
tau_true_tree[X_obs<0.33] <- 0.1
tau_true_tree[(X_obs>=0.33)&(X_obs<0.66)] <- 0.7
tau_true_tree[(X_obs>=0.66)] <- 0.3
tau_true_1 <- tau_true_tree + rnorm(length(tau_true_tree), sd = 0.01)
tau_true_1 <- matrix(tau_true_1, ncol = 1)
# periodoic
tau_true_2 <- 0.4*sin(2*pi*X_obs) + 0.5 + rnorm(length(tau_true_1), sd = 0.01)
plot(X_obs, tau_true_1, xlab = "Observations", ylab = "tau")
plot(X_obs, tau_true_2, xlab = "Observations", ylab = "tau")
# gauss # sin(tau*pi/2)
for (i in 1:2) {
assign(paste0("copula_uu_gauss_",i), BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",i)) * pi/2)))
}
# t # sin(tau*pi/2)
for (i in 1:2) {
assign(paste0("copula_uu_t_",i), BiCopSim(n, family = 2, par = sin(get(paste0("tau_true_",i)) * pi/2), par2 = 3))
}
# gumbel # 1/(1-tau)
for (i in 1:2) {
assign(paste0("copula_uu_gumbel_",i), BiCopSim(n, family = 4, par = 1/(1-get(paste0("tau_true_",i)))))
}
# clayton # (2*tau)/(1-tau)
for (i in 1:2) {
assign(paste0("copula_uu_clayton_",i), BiCopSim(n, family = 3, par = (2*get(paste0("tau_true_",i)))/(1-get(paste0("tau_true_",i)))))
}
# frank # numerical
for (i in 1:2) {
assign(paste0("copula_uu_frank_",i), BiCopSim(n, family = 5, par = BiCopTau2Par(5, get(paste0("tau_true_",i)))))
}
# dataset for prediction
X_obs_pred = matrix(runif(n), ncol = 1)
# normalise predictors
X_obs_pred.norm <- as.data.frame(apply(X_obs_pred, 2, \(x) (x - min(x))/(max(x) - min(x))))
X_obs_pred.norm <- as.matrix(X_obs_pred.norm)
rownames(X_obs_pred.norm) <- 1:nrow(X_obs_pred)
# tau with tree structure
tau_true_tree_pred <- rep(0,nrow(X_obs))
tau_true_tree_pred[X_obs_pred<0.33] <- 0.1
tau_true_tree_pred[(X_obs_pred>=0.33)&(X_obs_pred<0.66)] <- 0.7
tau_true_tree_pred[(X_obs_pred>=0.66)] <- 0.3
tau_true_pred_1 <- tau_true_tree_pred + rnorm(length(tau_true_tree_pred), sd = 0.01)
tau_true_pred_1 <- matrix(tau_true_pred_1, ncol = 1)
# periodic
tau_true_pred_2 <- 0.4*sin(2*pi*X_obs_pred) + 0.5 + rnorm(length(tau_true_1), sd = 0.01)
# mcmc params
n.chain_par <- 10
n.iter_par <- 6000
n.born.out.par <- 1000
n.thin <- 1
incl.split_par <- TRUE
cont.unif_par <- TRUE
moves.prob_par <- c(0.1, 0.4, 0.25, 0.25)
}
source('mclapply.R')
# source('MCMC_BART_copula.R')
source('import_functions.R')
source('test_MCMC_copula_mult_tree.R')
lb.prior.def <- list(fun = joint.prior.new.tree, param = c(1.5618883, 0.6293944))
for (i in 2) {
assign(paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = X_obs.norm,
U1 = get(paste0("copula_uu_gauss_",i))[,1],
U2 = get(paste0("copula_uu_gauss_",i))[,2],
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .4,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T))
cat('done case', i, '\n')
save(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), file = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt", ".Rdata"))
rm(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"))
}
library(library(MCMCpack))
library(MCMCpack)
for (i in 2) {
assign(paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = X_obs.norm,
U1 = get(paste0("copula_uu_gauss_",i))[,1],
U2 = get(paste0("copula_uu_gauss_",i))[,2],
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .4,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T))
cat('done case', i, '\n')
save(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), file = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt", ".Rdata"))
rm(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"))
}
library(pracma)
for (i in 2) {
assign(paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = X_obs.norm,
U1 = get(paste0("copula_uu_gauss_",i))[,1],
U2 = get(paste0("copula_uu_gauss_",i))[,2],
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .4,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T))
cat('done case', i, '\n')
save(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"), file = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt", ".Rdata"))
rm(list = paste0("gauss_mcmc_",i,"_tree_",n.tree,"_adapt"))
}
try_dat1<-mclapply_cbart(1:40, function(x)rnorm(100), mc.cores = 10)
# packages
library(VineCopula)
################################################################################
# data generation
################################################################################
set.seed(1e3)
n <- 500
X_obs <- matrix(runif(n), ncol = 1)
# normalise predictors
X_obs.norm <- as.data.frame(apply(X_obs, 2, \(x) (x - min(x))/(max(x) - min(x))))
X_obs.norm <- as.matrix(X_obs.norm)
rownames(X_obs.norm) <- 1:nrow(X_obs)
# tau with tree structure
tau_true_tree <- rep(0,nrow(X_obs))
tau_true_tree[X_obs<0.33] <- 0.2
tau_true_tree[(X_obs>=0.33)&(X_obs<0.66)] <- 0.7
tau_true_tree[(X_obs>=0.66)] <- 0.5
tau_true_1 <- tau_true_tree + rnorm(length(tau_true_tree), sd = 0.05)
tau_true_1 <- matrix(tau_true_1, ncol = 1)
# periodoic
tau_true_2 <- 0.2*sin(2*pi*X_obs) + 0.5 + rnorm(length(tau_true_1), sd = 0.05)
identical(BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2)),BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2)))
BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",i)) * pi/2))
BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2))
BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2))
BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2))
rnorm(10)
rnorm(10)
rnorm(10)
set.seed(123)
rnorm(10)
rnorm(10)
a<-rnorm(10)
b<-rnorm(10)
set.seed(123)
a<-rnorm(10)
set.seed(123)
b<-rnorm(10)
set.seed(123)
a<-BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2))
set.seed(123)
b<-BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",1)) * pi/2))
# packages
library(dplyr)
# dataset
cia_wf_data <- read.csv("countries.csv")
colnames_for_anlysis <- c("Country","People.and.Society..Life.expectancy.at.birth...male",
"People.and.Society..Life.expectancy.at.birth...female",
"People.and.Society..Literacy...male",
"People.and.Society..Literacy...female",
"Economy..Real.GDP.per.capita")
cia_wf_data <- cia_wf_data %>% dplyr::select(all_of(colnames_for_anlysis))
colnames(cia_wf_data) <- c("Country",
"Life_expectancy_M",
"Life_expectancy_F",
"Liter_M",
"Liter_F",
"GDP_PPP")
cia_wf_data = cia_wf_data %>%
mutate(across(-c(Country),.fns = parse_number))
library(readr)
cia_wf_data = cia_wf_data %>%
mutate(across(-c(Country),.fns = parse_number))
# packages
library(dplyr)
library(readr)
# dataset
cia_wf_data <- read.csv("countries.csv")
cia_wf_data <- cia_wf_data %>% dplyr::select(all_of(c("Country","People.and.Society..Life.expectancy.at.birth...male",
"People.and.Society..Life.expectancy.at.birth...female",
"People.and.Society..Literacy...male",
"People.and.Society..Literacy...female",
"Economy..Real.GDP.per.capita")))
colnames(cia_wf_data) <- c("Country",
"Life_expectancy_M",
"Life_expectancy_F",
"Liter_M",
"Liter_F",
"GDP_PPP")
cia_wf_data = cia_wf_data %>%
mutate(across(-c(Country),.fns = parse_number))
cia_wf_data <- na.omit(cia_wf_data_2023)
cia_wf_data <- na.omit(cia_wf_data)
plot(log(cia_wf_data_2023$GDP_PPP),cia_wf_data_2023$Life_expectancy_M)
plot(log(cia_wf_data$GDP_PPP),cia_wf_data$Life_expectancy_M)
plot(log(cia_wf_data$GDP_PPP),cia_wf_data$Life_expectancy_F)
plot(log(cia_wf_data$GDP_PPP),cia_wf_data$Liter_M)
plot(log(cia_wf_data$GDP_PPP),cia_wf_data$Liter_F)
U1_LE = ecdf(cia_wf_data$Life_expectancy_F)(cia_wf_data$Life_expectancy_F)
U2_LE = ecdf(cia_wf_data$Life_expectancy_M)(cia_wf_data$Life_expectancy_M)
U1_LT = ecdf(cia_wf_data$Liter_F)(cia_wf_data$Liter_F)
U2_LT = ecdf(cia_wf_data$Liter_M)(cia_wf_data$Liter_M)
plot(U1_LE,U2_LE)
plot(cia_wf_data$Life_expectancy_F,cia_wf_data$Life_expectancy_M)
plot(U1_LT,U2_LT)
plot(cia_wf_data$Liter_F,cia_wf_data$Liter_M)
GDP <- as.data.frame((log(cia_wf_data$GDP_PPP) - min(log(cia_wf_data$GDP_PPP)))/(max(log(cia_wf_data$GDP_PPP)) - min(log(cia_wf_data$GDP_PPP))))
GDP <- as.matrix(GDP)
rownames(GDP) <- 1:nrow(GDP)
n.chain_par <- 10
n.iter_par <- 15000
n.born.out.par <- 1000
n.thin <- 1
incl.split_par <- TRUE
cont.unif_par <- TRUE
moves.prob_par <- c(0.1, 0.4, 0.25, 0.25)
n.tree <- 10
source('MCMC_BART_copula.R')
source('import_functions.R')
lb.prior.def <- list(fun = joint.prior.new.tree, param = c(1.5618883, 0.6293944))
gauss_GDP_LE <- multichain_MCMC_copula(n.iter = n.iter_par, n.burn = n.born.out.par,
n.tree = n.tree, n.chain = n.chain_par, n.cores = 10,
X = GDP,
U1 = U1_LE,
U2 = U2_LE,
prior_list = lb.prior.def,
moves.prob = moves.prob_par,
starting.tree = NULL,
cont.unif = cont.unif_par,
include.split = incl.split_par,
prop_mu = 0, prop_sigma = .2,
theta_param_1 = 0, theta_param_2 = 1,
var_param_1 = 1, var_param_2 = 2,
prior_type = "N",
cop_type = "gauss",
adapt = T)
View(mclapply_cbart)
# packages
library(VineCopula)
################################################################################
# data generation
################################################################################
set.seed(1e3)
n <- 500
X_obs <- matrix(runif(n), ncol = 1)
# normalise predictors
X_obs.norm <- as.data.frame(apply(X_obs, 2, \(x) (x - min(x))/(max(x) - min(x))))
X_obs.norm <- as.matrix(X_obs.norm)
rownames(X_obs.norm) <- 1:nrow(X_obs)
# tau with tree structure
tau_true_tree <- rep(0,nrow(X_obs))
tau_true_tree[X_obs<0.33] <- 0.2
tau_true_tree[(X_obs>=0.33)&(X_obs<0.66)] <- 0.7
tau_true_tree[(X_obs>=0.66)] <- 0.5
tau_true_1 <- tau_true_tree + rnorm(length(tau_true_tree), sd = 0.05)
tau_true_1 <- matrix(tau_true_1, ncol = 1)
# periodoic
tau_true_2 <- 0.2*sin(2*pi*X_obs) + 0.5 + rnorm(length(tau_true_1), sd = 0.05)
plot(X_obs, tau_true_1, xlab = "Observations", ylab = "tau")
plot(X_obs, tau_true_2, xlab = "Observations", ylab = "tau")
for (i in 1:2) {
assign(paste0("copula_uu_gauss_",i), BiCopSim(n, family = 1, par = sin(get(paste0("tau_true_",i)) * pi/2)))
}
for (i in 1:2) {
assign(paste0("copula_uu_t_",i), BiCopSim(n, family = 2, par = sin(get(paste0("tau_true_",i)) * pi/2), par2 = 3))
}
for (i in 1:2) {
assign(paste0("copula_uu_gumbel_",i), BiCopSim(n, family = 4, par = 1/(1-get(paste0("tau_true_",i)))))
}
for (i in 1:2) {
assign(paste0("copula_uu_clayton_",i), BiCopSim(n, family = 3, par = (2*get(paste0("tau_true_",i)))/(1-get(paste0("tau_true_",i)))))
}
for (i in 1:2) {
assign(paste0("copula_uu_frank_",i), BiCopSim(n, family = 5, par = BiCopTau2Par(5, get(paste0("tau_true_",i)))))
}
plot(X_obs, tau_true_1, xlab = "Observations", ylab = "tau")
line(X_obs, tau_true_tree, col = 2)
plot(X_obs, tau_true_1, xlab = "Observations", ylab = "tau")
lines(X_obs, tau_true_tree, col = 2)
plot(X_obs, tau_true_1, xlab = "Observations", ylab = "tau")
points(X_obs, tau_true_tree, col = 2)
plot(X_obs, tau_true_2, xlab = "Observations", ylab = "tau")
points(X_obs, 0.2*sin(2*pi*X_obs) + 0.5, col = 2)
